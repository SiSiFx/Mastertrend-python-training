//@version=5
//indicator("MASTERTREND Strategy", shorttitle="MTS", overlay=true)

indicator("MASTERTREND FINAL", shorttitle="MTS", overlay=true)



vset = true
vsct = false
afa = false

LINE1MACD = input(13, title='line 1 MACD')
LINE2MACD = input(26, title='line 2 MACD')
div_reg_al = true
div_reg_ba = true
div_ocu_al = false
div_ocu_ba = false
labels = true

black = #000000
yellow = #FFFF00
gray = #C0C0C0
red = #FF0000
white = #FFFFFF
strong_green = #0AAC00

Periods = 10
src = hl2
Multiplier = 3
changeATR = true
showsignals = true
highlighting = true
atr2 = ta.sma(ta.tr, Periods)
atr = changeATR ? ta.atr(Periods) : atr2
up = src - Multiplier * atr
up1 = nz(up[1], up)
up := close[1] > up1 ? math.max(up, up1) : up
dn = src + Multiplier * atr
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn
trend = 1
trend := nz(trend[1], trend)
trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend

buySignal = trend == 1 and trend[1] == -1



sellSignal = trend == -1 and trend[1] == 1


longFillColor = highlighting ? trend == 1 ? color.green : color.white : color.white
shortFillColor = highlighting ? trend == -1 ? color.red : color.white : color.white

alertcondition(buySignal, title='SuperTrend Buy', message='SuperTrend Buy!')
alertcondition(sellSignal, title='SuperTrend Sell', message='SuperTrend Sell!')
changeCond = trend != trend[1]
alertcondition(changeCond, title='SuperTrend Direction Change', message='SuperTrend has changed direction!')



//JMA
jma(source, period, phase, power) =>
    phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5
    beta = 0.45 * (period - 1) / (0.45 * (period - 1) + 2)
    alpha = math.pow(beta, power)
    jma = 0.0
    e0 = 0.0
    e0 := (1 - alpha) * source + alpha * nz(e0[1])
    e1 = 0.0
    e1 := (source - e0) * (1 - beta) + beta * nz(e1[1])
    e2 = 0.0
    e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
    jma := e2 + nz(jma[1])
    jma

jmacd(source, fastlen, slowlen, siglen) =>
    dif = jma(source, fastlen, 0, 1.0)
    dea = jma(source, slowlen, 0, 1.0)
    macd = (dif - dea) * 1
    signal = ta.alma(macd,siglen, 0.85, 6)
    histo = (macd - signal) * 2
    [macd, signal, histo]


//MACD
[diff, dea, histo] = jmacd(hl2, 12, 26, 9)




//define MACD histogram
dif = histo
ghist = dif * 2
pos_ghist = math.max(0, ghist)
neg_ghist = math.min(0, ghist)
currhist = ghist[0]
prevhist = ghist[1]

//plot MACD histogram

_c = ta.ema(close, 3) - ta.ema(close, 8)
_o = ta.ema(open, 3) - ta.ema(open, 8)
_h = ta.ema(high, 3) - ta.ema(high, 8)
_l = ta.ema(low, 3) - ta.ema(low, 8)

long = (histo > 0 ? ta.crossover(_c, dea) : ta.crossover(_c, diff)) or _c > _o and ta.crossover(_c, 0)
short = histo > 0 ? ta.crossunder(_c, diff) : ta.crossunder(_c, dea) or _c < _o and ta.crossunder(_c, 0)


// MACD 1
L1 = LINE1MACD
L2 = LINE2MACD
tp2 = close
m0 = ta.ema(tp2, L1)
m1 = ta.ema(tp2, L2)
macd_1 = m0 - m1

// MACD 2

L1A = LINE1MACD
L2A = LINE2MACD
tpa = close
m0a = ta.ema(tpa, L1A)
m1a = ta.ema(tpa, L2A)
macd_2 = m0a - m1a



//Divergences
max = ta.highest(macd_2, 100) * 1.5
nsc=max
nsv = max * -1

midpoint = (nsc + nsv) / 2
ploff = (nsc - midpoint) / 8

f_top_fractal(_src) =>
     _src[4] < _src[2] and _src[3] < _src[2] and _src[2] > _src[1] and _src[2] > _src[0]
f_bot_fractal(_src) =>
     _src[4] > _src[2] and _src[3] > _src[2] and _src[2] < _src[1] and _src[2] < _src[0]
f_fractalize(_src) =>
     f_top_fractal(_src) ? 1 : f_bot_fractal(_src) ? -1 : 0

fractal_top1 = f_fractalize(macd_2) > 0 ? macd_2[2] : na
fractal_bot1 = f_fractalize(macd_2) < 0 ? macd_2[2] : na

high_prev1 = ta.valuewhen(fractal_top1, macd_2[2], 0)[2]
high_price1 = ta.valuewhen(fractal_top1, high[2], 0)[2]
low_prev1 = ta.valuewhen(fractal_bot1, macd_2[2], 0)[2]
low_price1 = ta.valuewhen(fractal_bot1, low[2], 0)[2]

regular_bearish_div1 = fractal_top1 and high[2] > high_price1 and macd_2[2] < high_prev1 and div_reg_ba == true
hidden_bearish_div1 = fractal_top1 and high[2] < high_price1 and macd_2[2] > high_prev1 and div_ocu_ba == true
regular_bullish_div1 = fractal_bot1 and low[2] < low_price1 and macd_2[2] > low_prev1 and div_reg_al == true
hidden_bullish_div1 = fractal_bot1 and low[2] > low_price1 and macd_2[2] < low_prev1 and div_ocu_al == true

col1 = regular_bearish_div1 ? red : hidden_bearish_div1 ? red: na
col2 = regular_bullish_div1 ? strong_green : hidden_bullish_div1 ? strong_green : na
//JMA INTEGRATION 
lengthjma = 7
phase = 50
power = 2
srcjma = close
highlightMovements = true

phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5

beta = 0.45 * (lengthjma - 1) / (0.45 * (lengthjma - 1) + 2)
alpha = math.pow(beta, power)

jma = 0.0

e0 = 0.0
e0 := (1 - alpha) * srcjma + alpha * nz(e0[1])

e1 = 0.0
e1 := (srcjma - e0) * (1 - beta) + beta * nz(e1[1])

e2 = 0.0
e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])

jma := e2 + nz(jma[1])

jmaColor = highlightMovements ? jma > jma[1] ? color.green : color.red : #6d1e7f
//plot(jma, title='JMA', linewidth=2, color=jmaColor)

heikUpColor() => hlc3 >= jma
heikDownColor() => hlc3 < jma[1]






//Estrategia
var bool toBuy = false
var bool toSell = false
if ta.crossover(macd_2, 0) and macd_1 < macd_2 and macd_1[1] < macd_1[0] and macd_1 < 0 and vset
    toBuy := true
    toSell := false
    toSell
else if ta.crossunder(macd_2, 0) and macd_1 > macd_2 and macd_1[1] > macd_1[0] and macd_1 > 0 and vset
    toSell := true
    toBuy := false
    toBuy

largo = ta.crossover(macd_2, 0) and macd_1 < macd_2 and macd_1[1] < macd_1[0] and macd_1 < 0 and vset
largo1 = ta.crossover(macd_2, macd_1) and macd_2 < 0 and vsct


corto = ta.crossunder(macd_2, 0) and macd_1 > macd_2 and macd_1[1] > macd_1[0] and macd_1 > 0 and vset
corto1 = ta.crossunder(macd_2, macd_1) and macd_2 > 0 and vsct


//Alertas
alertcondition(largo or largo1, title='Compras')
alertcondition(corto or corto1, title='Ventas')
alertcondition(largo or largo1 or corto or corto1, title='Compras/Ventas')

PORTO= regular_bullish_div1 and div_reg_al and labels ? macd_2[1] - ploff * 0.5 : na
PROTO=regular_bearish_div1 and div_reg_ba and labels ? macd_2[1] + ploff * 0.5 : na
cond = PORTO
cond2=PROTO

var int count = na

if cond
    count := 0
else
    count += 1
if cond2
    count := 0
else
    count += 1

since_last = ta.barssince(cond)
since_last2 = ta.barssince(cond2)




bearcond = since_last < since_last2
bullcond = since_last > since_last2




//MACD
fastMA = input.int(title='Fast moving average', defval=12, minval=1)
slowMA = input.int(title='Slow moving average', defval=26, minval=1)
lastColor = color.yellow
[currMacd, _, _] = ta.macd(close[0], fastMA, slowMA, 9)
[prevMacd, _, _] = ta.macd(close[1], fastMA, slowMA, 9)


crossmacdbear= ta.crossover(currMacd,0)
crossmacd = ta.crossunder(currMacd,0)

hilow = (high - low) * 100
openclose = (close - open) * 100
vol = close / hilow
spreadv = openclose * close
pt = spreadv + ta.cum(spreadv)
e31 = 5
m = 9
l31 = 14
a1 = ta.ema(pt, l31) - ta.ema(pt, m)
b1 = ta.ema(pt, e31) - ta.ema(pt, m)
p1 = a1 + b1



// bullish signal rule: 
bullishRule = b1 >= p1
// bearish signal rule: 
bearishRule = b1 <= p1
// current trading State
ruleState = 0
ruleState := bullishRule ? 1 : bearishRule ? -1 : nz(ruleState[1])



//STOP MANAGEMENT 


bool inputShowWilliamsFractals = true
bool inputShowWilliamsStops = true
bool inputShowWilliamsStopPrice = true
int inputWilliamsLeftRange = 2
int inputWilliamsRightRange =2
float inputWilliamsStopBufferInput =0



// ============================== WILLIAMS PRICE FRACTALS: CALCULATE AND PLOT FRACTALS ==================================

f_IsWilliamsFractal(_williamsLeftRange, _williamsRightRange, _type) =>
    // This function checks whether a Williams High/Low has formed. If so, it returns a bool true for Yes, the number of bars back from the current bar that the fractal formed, and the value of the fractal.
    // Note: Because fractals are always confirmed a known number of bars after the fact, we have to be careful when using this bool to look up values later.
    _isWilliamsFractal = _type == 'high' and high[_williamsRightRange] >= ta.highest(high, _williamsLeftRange + _williamsRightRange + 1) or _type == 'low' and low[_williamsRightRange] <= ta.lowest(low, _williamsLeftRange + _williamsRightRange + 1)  // Passing in the _type allows us to use just one function to do both highs and lows
    _fractalValue = _isWilliamsFractal and _type == 'high' ? high[_williamsRightRange] : _isWilliamsFractal and _type == 'low' ? low[_williamsRightRange] : na
    [_isWilliamsFractal, _fractalValue]

// Check if current bar confirms a Williams High or Low
[isWilliamsHigh, williamsHighPrice] = f_IsWilliamsFractal(inputWilliamsLeftRange, inputWilliamsRightRange, 'high')
[isWilliamsLow, williamsLowPrice] = f_IsWilliamsFractal(inputWilliamsLeftRange, inputWilliamsRightRange, 'low')

// Suppress fractals if the previous bar was a fractal. This will take care of the edge case where you have two bars closing at the same price in a row.
isWilliamsHigh := isWilliamsHigh[1] ? false : isWilliamsHigh
isWilliamsLow := isWilliamsLow[1] ? false : isWilliamsLow

// Plot the fractal shapes. They need to be offset backwards so they appear over the correct bar.
williamsHighOffset = 0 - inputWilliamsRightRange  // Using this variable is a workaround because if you add -inputWilliamsRightRange to the offset it doesn't work
color white10 = color.new(color.white, 10)  // Define a new colour with transparency of 10 to avoid compilation warnings

williamsLowOffset = 0 - inputWilliamsRightRange



// ============================== WILLIAMS PRICE FRACTALS: CALCULATE AND PLOT TRAILING STOP LINES ==================================

f_addPercentBuffer(_input, _buffer, _direction) =>
    // This function adds/removes a percentage buffer to/from the input. It's easy enough to include the calculation each time but I was on a roll with functions by this point.
    _direction == 'plus' ? _input * (1 + _buffer / 100) : _direction == 'minus' ? _input * (1 - _buffer / 100) : na

// Add the percentage buffer to the fractal price.
williamsLowPriceBuffered = f_addPercentBuffer(williamsLowPrice, inputWilliamsStopBufferInput, 'minus')
williamsHighPriceBuffered = f_addPercentBuffer(williamsHighPrice, inputWilliamsStopBufferInput, 'plus')

f_persistAndReset(_trigger, _source) =>
    // This function returns the value of _source when _trigger is true, persists it, and resets it to the new value of _source when _trigger is true again.
    var float _output = 0.0
    _output := _trigger ? _source : _output[1]
    _output

// Persist the buffered stop price and reset it each time there is a new fractal
williamsLongStopPrice = f_persistAndReset(isWilliamsLow, williamsLowPriceBuffered)
williamsShortStopPrice = f_persistAndReset(isWilliamsHigh, williamsHighPriceBuffered)

f_trail(_source, _trail, _direction) =>
    // This function trails the source series up or down.
    // Note: depending what you're trailing, and how you're resetting it later, you might want to test against _trail[0] instead of _trail[1]
    _direction == 'down' and _source >= _trail[1] ? _trail : _direction == 'up' and _source <= _trail[1] ? _trail : _source

// Need to declare these variables here, in the global scope, so we can use them in other functions later
var float williamsLongStopPriceTrail = williamsLongStopPrice
var float williamsShortStopPriceTrail = williamsShortStopPrice

// Trail the high (short) stop down and the low (long) stop up
williamsShortStopPriceTrail := f_trail(williamsShortStopPrice, williamsShortStopPriceTrail, 'down')
williamsLongStopPriceTrail := f_trail(williamsLongStopPrice, williamsLongStopPriceTrail, 'up')

f_flip(_flipInput, _longTrail, _shortTrail, _longReset, _shortReset) =>
    // This function flips from a trailing long stop to a trailing short stop and vice-versa. It takes the following inputs:
        // _flipInput - A string that defines whether to consider a touch of the stop line as a flip, or a close beyond it
        // _longTrail - The long trailing stop (trails up, below the price)
        // _shortTrail - The short trailing stop (trails down, above the price)
        // _longReset - The value to reset the long stop to, when it's hit
        // _shortReset - The value to reset the short stop to, when it's hit
    // The function returns the following outputs:
        // _longTrailOutput - The long trailing stop. Normally the same as it was input, unless it's reset.
        // _shortTrailOutput - The short trailing stop. Normally the same as it was input, unless it's reset.
        // _longTrailPlot - The long trailing stop to plot. This is na if we are not long.
        // _shortTrailPlot - The short trailing stop to plot. This is na if we are not short.
    //
    // These variables say whether we are flipping long or short this very bar. Usually they are both false. Only one of them can be true at once.
    var bool _flipLongNow = false
    var bool _flipShortNow = false
    // These variables say what state we're in: long or short. One or both are always true.
    // In the beginning, we haven't hit any trails yet, so we start off both long and short, to display both lines.
    var bool _isLong = true
    var bool _isShort = true
    // Get the source, depending whether it's on close or on touch
    float _flipLongSource = _flipInput == 'Close' ? close : _flipInput == 'Wick' ? high : na
    float _flipShortSource = _flipInput == 'Close' ? close : _flipInput == 'Wick' ? low : na
    // Are we flipping long or short this bar?
    _flipLongNow := _isShort[1] and _flipLongSource > _shortTrail ? true : false
    _flipShortNow := _isLong[1] and _flipShortSource < _longTrail ? true : false
    // In the edge case where we manage to flip both long and short, we need to reset that based on the close. The close is definitive for history and intra-candle it will take the current value.
    _flipLongNow := _flipShortNow and _flipLongNow and close > _longTrail ? true : _flipShortNow and _flipLongNow and close <= _longTrail ? false : _flipLongNow
    _flipShortNow := _flipLongNow and _flipShortNow and close < _shortTrail ? true : _flipShortNow and _flipLongNow and close >= _shortTrail ? false : _flipShortNow
    // Set the long and short state variables. Set if we flip (simple), initialise to true if this is the first time (needed), otherwise persist.
    _isLong := _flipLongNow ? true : _flipShortNow ? false : na(_isLong[1]) ? true : _isLong[1]
    _isShort := _flipShortNow ? true : _flipLongNow ? false : na(_isShort[1]) ? true : _isShort[1]
    // Update the trailing price. If we flip this bar, reset to the nearest fractal - which goes against the trail direction, which is why we need to use another series.
    _longTrailOutput = _longTrail
    _shortTrailOutput = _shortTrail
    _longTrailOutput := _isLong and not _isLong[1] ? _longReset : _longTrailOutput
    _shortTrailOutput := _isShort and not _isShort[1] ? _shortReset : _shortTrailOutput
    // Hide the trailing long stop if we are short, and hide the trailing short stop if we are long. Show both if we are both long and short.
    float _longTrailPlot = _isLong ? _longTrailOutput : _isLong and _isShort ? _longTrailOutput : na
    float _shortTrailPlot = _isShort ? _shortTrailOutput : _isLong and _isShort ? _shortTrailOutput : na
    [_longTrailOutput, _shortTrailOutput, _longTrailPlot, _shortTrailPlot]

f_getFlipResetWilliamsLong(_longTrail, _buffer, _isWilliamsLow, _williamsRightRange) =>
    // This function gets the long stop price to reset to. This is unnecessary for ATR trails, but Williams fractals trails are more complicated.
    // The fractal that we would reset to is not always confirmed at the time we flip, so we take the lower of the last confirmed fractal and the Lows of the intervening bars.
    _barIndexWhenLastFractalConfirmed = ta.valuewhen(_isWilliamsLow, bar_index, 0)  // Get the number of bars since the last fractal was confirmed (not formed)
    _barsSinceLastFractalConfirmed = bar_index - _barIndexWhenLastFractalConfirmed  // And get the total number of bars back to go from the current bar
    int _barsToGoBack = _barsSinceLastFractalConfirmed + _williamsRightRange  // Then add the number of bars in the Williams lag
    // Go that number of bars back and get the lowest low
    float _lowestLow = low
    for i = 0 to _barsToGoBack by 1
        _lowestLow := math.min(low[i], _lowestLow)
        _lowestLow
    _lowestLowAdjusted = _lowestLow * (1 - _buffer / 100)
    _lowestLowAdjusted

f_getFlipResetWilliamsShort(_shortTrail, _buffer, _isWilliamsHigh, _williamsLeftRange) =>
    // This function is the short stop equivalent of f_getFlipResetWilliamsLong
    _barIndexWhenLastFractalConfirmed = ta.valuewhen(_isWilliamsHigh, bar_index, 0)
    _barsSinceLastFractalConfirmed = bar_index - _barIndexWhenLastFractalConfirmed
    int _barsToGoBack = _barsSinceLastFractalConfirmed + _williamsLeftRange
    float _highestHigh = high
    for i = 0 to _barsToGoBack by 1
        _highestHigh := math.max(high[i], _highestHigh)
        _highestHigh
    _highestHighAdjusted = _highestHigh * (1 + _buffer / 100)
    _highestHighAdjusted

// Get the long/short stop price to reset to. It's normally the most recent opposing fractal, but the function takes care of edge cases where the most recent fractal isn't confirmed yet.
williamsLongStopPrice := f_getFlipResetWilliamsLong(williamsLongStopPrice, inputWilliamsStopBufferInput, isWilliamsLow, inputWilliamsRightRange)
williamsShortStopPrice := f_getFlipResetWilliamsShort(williamsShortStopPrice, inputWilliamsStopBufferInput, isWilliamsHigh, inputWilliamsRightRange)

// Get the plots for the trails, to show only long stop when long and short stop when short.
[williamsLongStopPriceTrailTemp, williamsShortStopPriceTrailTemp, williamsLongStopPriceTrailPlot, williamsShortStopPriceTrailPlot] = f_flip("Close", williamsLongStopPriceTrail, williamsShortStopPriceTrail, williamsLongStopPrice, williamsShortStopPrice)

// Have to have these variables back in the global scope so we can persist them and use them as inputs to the function next bar.
// I don't think there's a way round this because assigning multiple mutable variables via a function doesn't seem to work.
williamsLongStopPriceTrail := williamsLongStopPriceTrailTemp
williamsShortStopPriceTrail := williamsShortStopPriceTrailTemp

// Hide trailing stop plots if the user selected that (input bool inputShowWilliamsStops)
williamsShortStopPriceTrailPlotDisplay = inputShowWilliamsStops ? williamsShortStopPriceTrailPlot : na
williamsLongStopPriceTrailPlotDisplay = inputShowWilliamsStops ? williamsLongStopPriceTrailPlot : na

// Plot the trailing stops
color yellow50 = color.new(color.yellow, 50)
color yellow0 = color.new(color.yellow, 0)
color orange50 = color.new(color.orange, 50)
color orange0 = color.new(color.orange, 0)

Curly_Fries = 150
Popeyes = 200
Chicken_Sandwich = 250
ema_150 = ta.ema(close, Curly_Fries)
ema_200 = ta.ema(close, Popeyes)
ema_250 = ta.ema(close, Chicken_Sandwich)

// Trend analysis
trendUp = ta.ema(close, 10) > ta.ema(close, 20)
trendDn = ta.ema(close, 10) < ta.ema(close, 20)

// Determine Candle size
candleSize = math.abs(high - low)

// Determine Stop/Entry gap
highest_1 = ta.highest(4)
lowest_1 = ta.lowest(4)
lowest_2 = ta.lowest(4)
stopGap = trendDn and high < ta.highest(4) ? math.abs(highest_1 - low) : trendUp and low > lowest_1 ? math.abs(high - lowest_2) : 0.0

// Change color if stop/entry gap or candle size smaller than median of prev 10
med = ta.percentile_linear_interpolation(candleSize, 10, 50)
x = candleSize > med ? color.gray : stopGap > med ? #b3b3b3 : #53B987
// ============================== WILLIAMS PRICE FRACTALS: ALERTS ==================================


// Alert for crossing the trailing stop. You can set this to trigger Once, or Once per bar close, in the TradingView alert configuration screen. You can use this for soft stops or to look for entries.
// Calculate if we crossed a trailing line. Not going to do the calculation again, just cheat and use the plot that we did before.
// Have to choose the right one. It does matter that it was shown and hidden according to the flip, but it doesn't matter if the user hid it.
alertCrossWilliamsLongStop = na(williamsLongStopPriceTrailPlot) and not na(williamsLongStopPriceTrailPlot[1])
alertCrossWilliamsShortStop = na(williamsShortStopPriceTrailPlot) and not na(williamsShortStopPriceTrailPlot[1])

alertcondition(alertCrossWilliamsLongStop, title='Crossed Williams Long Stop', message='Alert from Williams Fractal Trailing Stops: \n {{ticker}} price crossed long stop')
alertcondition(alertCrossWilliamsShortStop, title='Crossed Williams Short Stop', message='Alert from Williams Fractal Trailing Stops: \n {{ticker}} price crossed short stop')

alertcondition(isWilliamsHigh, title='High Printed', message='Alert from Williams Fractal Trailing Stops: \n {{ticker}} Williams High has been confirmed')
alertcondition(isWilliamsLow, title='Low Printed', message='Alert from Williams Fractal Trailing Stops: \n {{ticker}} Williams Low has been confirmed')


// Paramètres ajustables
length_ema = input(20, "EMA Length")
atr_length = input(14, "ATR Length")
rsi_length = input(14, "RSI Length")
volume_mult = input(1.5, "Volume Multiplier")

// Calculs des indicateurs
ema = ta.ema(close, length_ema)

rsi = ta.rsi(close, rsi_length)
vol_ma = ta.sma(volume, 20)

// Conditions de tendance
trend_up = close > ema
trend_down = close < ema

// Conditions de volatilité
volatility_high = ta.atr(atr_length) > ta.sma(ta.atr(atr_length), 20)

// Conditions de volume
volume_surge = volume > vol_ma * volume_mult

// Conditions de momentum
rsi_oversold = rsi < 30
rsi_overbought = rsi > 70

// Conditions de confirmation de prix
price_confirmation_up = close > high[1] and open < close
price_confirmation_down = close < low[1] and open > close

// Conditions finales pour les signaux
// Signal d'achat amélioré
bb = trend_up and not volatility_high and volume_surge and rsi_oversold and price_confirmation_up
ss = trend_down and not volatility_high and volume_surge and rsi_overbought and price_confirmation_down

// Filtres supplémentaires pour éviter les faux signaux
timeFilter = time >= timestamp(year, month, dayofmonth, 9, 30) and time <= timestamp(year, month, dayofmonth, 16, 00)
            

// Gestion des stops et targets
stopLoss = atr * 1.5
takeProfit = atr * 3

// Conditions finales avec tous les filtres
validBuyEntry = buySignal and timeFilter
validSellEntry = sellSignal and timeFilter


// Two Way Alert generator


bgColor = input.bool(false, "Activate High/Low View")
LondonColor = color.new(color.green, 90)
NYColor = color.new(color.red, 90)
AsiaColor = color.new(color.yellow, 90)
SydneyColor = color.new(color.blue, 90)

///Sessions

res = input.timeframe("D", "Resolution", ["D","W","M"])
london = input.session("0300-1200:1234567", "London Session")
ny = input.session("0800-1700:1234567", "New York Session")
tokyo = input.session("2000-0400:1234567", "Tokyo Session")
sydney = input.session("1700-0200:1234567", "Sydney Session")

//Bars

is_newbar(sess) =>
    t = time(res, sess, "America/New_York")
    na(t[1]) and not na(t) or t[1] < t

is_session(sess) =>
    not na(time(timeframe.period, sess, "America/New_York"))
    

//London

London = input.bool(true, "London Session")

londonNewbar = is_newbar(london)
londonSession = is_session(london)

float londonLow = na
londonLow := if londonSession
    if londonNewbar
        low
    else
        math.min(londonLow[1],low)
else
    londonLow

float londonHigh = na
londonHigh := if londonSession
    if londonNewbar
        high
    else
        math.max(londonHigh[1],high)
else
    londonHigh


plotLL = plot(londonLow, color=color.new(#000000, 100))
plotLH = plot(londonHigh, color=color.new(#000000, 100))
fill(plotLL, plotLH, color = londonSession and London and bgColor ? LondonColor : na)

bgcolor(londonSession and London and not bgColor ? LondonColor : na)



//New York

NY = input.bool(true, "New York Session")

nyNewbar = is_newbar(ny)
nySession = is_session(ny)

float nyLow = na
nyLow := if nySession
    if nyNewbar
        low
    else
        math.min(nyLow[1],low)
else
    nyLow

float nyHigh = na
nyHigh := if nySession
    if nyNewbar
        high
    else
        math.max(nyHigh[1],high)
else
    nyHigh


plotNYL = plot(nyLow, color=color.new(#000000, 100))
plotNYH = plot(nyHigh, color=color.new(#000000, 100))
fill(plotNYL, plotNYH, color = nySession and NY and bgColor ? NYColor : na)

bgcolor(nySession and NY and not bgColor ? NYColor : na)


//Tokyo

Tokyo = input.bool(true, "Tokyo Session")

tokyoNewbar = is_newbar(tokyo)
tokyoSession = is_session(tokyo)

float tokyoLow = na
tokyoLow := if tokyoSession
    if tokyoNewbar
        low
    else
        math.min(tokyoLow[1],low)
else
    tokyoLow

float tokyoHigh = na
tokyoHigh := if tokyoSession
    if tokyoNewbar
        high
    else
        math.max(tokyoHigh[1],high)
else
    tokyoHigh


plotTL = plot(tokyoLow, color=color.new(#000000, 100))
plotTH = plot(tokyoHigh, color=color.new(#000000, 100))
fill(plotTL, plotTH, color = tokyoSession and Tokyo and bgColor ? AsiaColor : na)

bgcolor(tokyoSession and Tokyo and not bgColor ? AsiaColor : na)



//Sydney

Sydney = input.bool(false, "Sydney Session")

sydneyNewbar = is_newbar(sydney)
sydneySession = is_session(sydney)

float sydneyLow = na
sydneyLow := if sydneySession
    if sydneyNewbar
        low
    else
        math.min(sydneyLow[1],low)
else
    sydneyLow

float sydneyHigh = na
sydneyHigh := if sydneySession
    if sydneyNewbar
        high
    else
        math.max(sydneyHigh[1],high)
else
    sydneyHigh


plotSL = plot(sydneyLow, color=color.new(#000000, 100))
plotSH = plot(sydneyHigh, color=color.new(#000000, 100))
fill(plotSL, plotSH, color = sydneySession and Sydney and bgColor ? SydneyColor : na)

bgcolor(sydneySession and Sydney and not bgColor ? SydneyColor : na)

//TREND TABLE 


// == USER INPUT ==
tableLocation = input.string(defval='Top', options=['Top', 'Bottom'], title='Info Table Location', group='Display', 
  tooltip='Place information table on the top of the pane or the bottom of the pane.')
lookback = input.int(defval=3, title='Pivot Lookback Period', group='Pivot Points', 
  tooltip='Looks for pivot points within this number of bars both left and right.')
pivotType = input.string(defval = "High/Low", title = "Pivot Type", options = ["High/Low","Close"], group = 'Pivot Points',
  tooltip = 'Choose whether the high/low or close is used for pivot points and trend calcuations.')
showPivotPoints = input.bool(title='Show Historical Pivot Points?', defval=false, group='Pivot Points', 
  tooltip='Toggle this on to see the historical pivot points that were used.  Change the Lookback Period to adjust the 
  frequency of these points. The pivot points are only shown for the current chart timeframe - to see the Daily pivot pionts, use the Daily timeframe, etc.')
oneSet = input.timeframe(defval='240', title='First Timeframe', group='Higher Timeframe Levels', 
  tooltip='Allows you to set different time frames for looking at the trend. Important: Does not work for lower timeframes than the current
  chart timeframe.')
twoSet = input.timeframe(defval='D', title='Second Timeframe', group='Higher Timeframe Levels')
threeSet = input.timeframe(defval='W', title='Third Timeframe', group='Higher Timeframe Levels')
fourSet = input.timeframe(defval='M', title='Fourth Timeframe', group='Higher Timeframe Levels')
showMTFLevels = input.bool(title='Show Multiple Timeframe S/R Levels?', defval=true, group='Higher Timeframe Levels', 
  tooltip='Displays the pivot highs and lows of higher timeframes to use as support/resistance levels. When these levels break, 
  the trend will change on these higher timeframes.')
oneColorS = input.color(color.new(color.orange, 50), title='1st Timeframe    Support', group='Higher Timeframe Levels', inline='MTF1')
oneColorR = input.color(color.new(color.orange, 50), title=' Resistance', group='Higher Timeframe Levels', inline='MTF1')
twoColorS = input.color(color.new(color.blue, 50), title='2nd Timeframe   Support', group='Higher Timeframe Levels', inline='MTF2')
twoColorR = input.color(color.new(color.blue, 50), title=' Resistance', group='Higher Timeframe Levels', inline='MTF2')
threeColorS = input.color(color.new(color.white, 50), title='3rd Timeframe    Support', group='Higher Timeframe Levels', inline='MTF3')
threeColorR = input.color(color.new(color.white, 50), title=' Resistance', group='Higher Timeframe Levels', inline='MTF3')
fourColorS = input.color(color.new(color.red, 50), title='4th Timeframe    Support', group='Higher Timeframe Levels', inline='MTF4')
fourColorR = input.color(color.new(color.red, 50), title=' Resistance', group='Higher Timeframe Levels', inline='MTF4')
levelWidth = input.int(defval=1, title='Line Width (pixels)', group='Higher Timeframe Levels')

//  == DEFINE FUNCTIONS FOR USE IN MULTIPLE TIMEFRAMES (USING A TUPLE TO AVOID SO MANY SECURITY CALLS) ==  
f_getHTF() =>
    var float ph = na, float pl = na, float highLevel = na, float lowLevel = na
    if pivotType == "Close"
        ph := ta.pivothigh(close, lookback, lookback)
        pl := ta.pivotlow(close, lookback, lookback)
        highLevel := ta.valuewhen(ph, close[lookback], 0)
        lowLevel := ta.valuewhen(pl, close[lookback], 0)
    else 
        ph := ta.pivothigh(high, lookback, lookback)
        pl := ta.pivotlow(low, lookback, lookback)
        highLevel := ta.valuewhen(ph, high[lookback], 0)
        lowLevel := ta.valuewhen(pl, low[lookback], 0)
    barsSinceHigh = ta.barssince(ph) + lookback
    barsSinceLow = ta.barssince(pl) + lookback
    timeSinceHigh = time[barsSinceHigh]
    timeSinceLow = time[barsSinceLow]
    [ph, pl, highLevel, lowLevel, barsSinceHigh, barsSinceLow, timeSinceHigh, timeSinceLow]

[ph_01, pl_01, hL_01, lL_01, bsSH_01, bsSL_01, tSH_01, tSL_01] = request.security(syminfo.tickerid, oneSet, f_getHTF())
[ph_02, pl_02, hL_02, lL_02, bsSH_02, bsSL_02, tSH_02, tSL_02] = request.security(syminfo.tickerid, twoSet, f_getHTF())
[ph_03, pl_03, hL_03, lL_03, bsSH_03, bsSL_03, tSH_03, tSL_03] = request.security(syminfo.tickerid, threeSet, f_getHTF())
[ph_04, pl_04, hL_04, lL_04, bsSH_04, bsSL_04, tSH_04, tSL_04] = request.security(syminfo.tickerid, fourSet, f_getHTF())

// Check to ensure boxes are all higher timeframe than the chart to remove glyph and gray out box if that's the case
tfInMinutes(simple string tf = "") =>
    float chartTf =
      timeframe.multiplier * (
      timeframe.isseconds ? 1. / 60             :
      timeframe.isminutes ? 1.                  :
      timeframe.isdaily   ? 60. * 24            :
      timeframe.isweekly  ? 60. * 24 * 7        :
      timeframe.ismonthly ? 60. * 24 * 30.4375  : na)
    float result = tf == "" ? chartTf : request.security(syminfo.tickerid, tf, chartTf)
    
float chartTFInMinutes = tfInMinutes()
bool TF1Check = tfInMinutes(oneSet) < chartTFInMinutes
bool TF2Check = tfInMinutes(twoSet) < chartTFInMinutes
bool TF3Check = tfInMinutes(threeSet) < chartTFInMinutes
bool TF4Check = tfInMinutes(fourSet) < chartTFInMinutes

// Current timeframe pivots
var float phC = na, float plC = na
if pivotType == "High/Low"
    phC := ta.pivothigh(high, lookback, lookback)
    plC := ta.pivotlow(low, lookback, lookback)
else
    phC := ta.pivothigh(close, lookback, lookback)
    plC := ta.pivotlow(close, lookback, lookback)

// Plot historical pivot points for debugging and configuring the lookback period.
plot(showPivotPoints ? phC : na, style=plot.style_cross, linewidth=3, color=color.new(color.yellow, 50), offset=-lookback)
plot(showPivotPoints ? plC : na, style=plot.style_cross, linewidth=3, color=color.new(color.yellow, 50), offset=-lookback)

// == PLOT SUPPORT/RESISTANCE LINES ON THE HIGHER TIMEFRAMES ==
// Use a function to define the lines
f_line(x1, y1, y2, _color) =>
    var line id = na
    line.delete(id)
    id := line.new(x1, y1, time, y2, xloc.bar_time, extend.right, _color, width=levelWidth)
    id


// == TREND CALCULATIONS (USING A TUPLE TO CONSOLIDATE REPETATIVE CODE AND GENERATE MULTIPE VARIABLES WITH ONE FUNCTION ==
f_signal(highLevel, lowLevel) =>
    uptrendSignal = high > highLevel
    downtrendSignal = low < lowLevel
    inUptrend = bool(na)
    inDowntrend = bool(na)
    inUptrend := uptrendSignal[1] ? true : downtrendSignal[1] ? false : inUptrend[1]
    inDowntrend := not inUptrend
    [uptrendSignal, downtrendSignal, inUptrend, inDowntrend]

[uptrendSignal1, downtrendSignal1, inUptrend1, inDowntrend1] = f_signal(hL_01, lL_01)  // 1st Timeframe
[uptrendSignal2, downtrendSignal2, inUptrend2, inDowntrend2] = f_signal(hL_02, lL_02)  // 2nd Timeframe
[uptrendSignal3, downtrendSignal3, inUptrend3, inDowntrend3] = f_signal(hL_03, lL_03)  // 3rd Timeframe
[uptrendSignal4, downtrendSignal4, inUptrend4, inDowntrend4] = f_signal(hL_04, lL_04)  // 3rd Timeframe

// Input parameters
atrLength = input.int(title="ATR Length", defval=14, minval=1)
atrMultiplier = input.float(title="ATR Multiplier", defval=1.0, minval=0.1)

// Calculating stop loss prices
longStopPrice = close - (atr * atrMultiplier)
shortStopPrice = close + (atr * atrMultiplier)

// Round the stop loss prices to 2 decimal places (adjust as needed)
longStopPriceRounded = math.round(longStopPrice * 1) / 1
shortStopPriceRounded = math.round(shortStopPrice * 1) / 1

// Define your account ID and symbol
accountID = "BGUSER-SPY2VE51"  // Replace with your actual account ID
symbol = syminfo.ticker

// Function to format the alert message
f_alertMessage(_accountID, _symbol, _action, _stopLossPrice) =>
    str.format("{0} {1} {2} {3}", _accountID, _symbol, _action, _stopLossPrice)

// Conditions for Buy Signal
longCondition = williamsLongStopPriceTrailPlotDisplay and crossmacdbear and (b1 >= p1) and (trend == 1) and (stopGap > med) and (London and londonSession or NY and nySession or Tokyo and tokyoSession or Sydney and sydneySession) 

// Plotting the Buy Signal
plotshape(longCondition, title='Buy Signal', text='BUY', textcolor=color.white, style=shape.labelup, location=location.belowbar, color=color.green, size=size.tiny)

// Conditions for Sell Signal
shortCondition = williamsShortStopPriceTrailPlotDisplay and crossmacd and (b1 <= p1) and (trend == -1) and (stopGap > med) and (London and londonSession or NY and nySession or Tokyo and tokyoSession or Sydney and sydneySession)

// Plotting the Sell Signal
plotshape(shortCondition, title='Sell Signal', text='SELL', textcolor=color.white, style=shape.labeldown, location=location.abovebar, color=color.red, size=size.tiny)


// Alert message function (for regular alerts)
alertMessage(_action) =>
    _action + " " + syminfo.ticker

// Generate alerts for conditions
if longCondition
    alert(alertMessage("BUY"), alert.freq_once_per_bar_close)

if shortCondition
    alert(alertMessage("SELL"), alert.freq_once_per_bar_close)

// Alert conditions (using {{ticker}} syntax)
alertcondition(longCondition, title='BULL Signal', message="BUY {{ticker}}")
alertcondition(shortCondition, title='BEAR Signal', message="SELL {{ticker}}")
barcolor = if longCondition
    color.green
else if shortCondition
    color.red
else
    na

barcolor(barcolor)





// Compteurs pour la durée et la distance
var float sumLongBars = 0
var float sumShortBars = 0
var float sumLongDistance = 0
var float sumShortDistance = 0
var int countLong = 0
var int countShort = 0
var int currentCount = 0
var float startPrice = 0
var bool inLong = false
var bool inShort = false

// Réinitialisation lors d'un nouveau signal
if longCondition
    inLong := true
    inShort := false
    currentCount := 0
    startPrice := close
    
if shortCondition
    inShort := true
    inLong := false
    currentCount := 0
    startPrice := close

// Compte les barres et la distance
if inLong and close > open
    currentCount := currentCount + 1
else if inLong
    sumLongBars := sumLongBars + currentCount
    sumLongDistance := sumLongDistance + (high - startPrice)
    countLong := countLong + 1
    inLong := false

if inShort and close < open
    currentCount := currentCount + 1
else if inShort
    sumShortBars := sumShortBars + currentCount
    sumShortDistance := sumShortDistance + (startPrice - low)
    countShort := countShort + 1
    inShort := false

// Calcul des moyennes
avgLongBars = countLong > 0 ? sumLongBars / countLong : 0
avgShortBars = countShort > 0 ? sumShortBars / countShort : 0
avgLongDistance = countLong > 0 ? sumLongDistance / countLong : 0
avgShortDistance = countShort > 0 ? sumShortDistance / countShort : 0

// Calcul du pourcentage moyen
avgLongPercent = countLong > 0 ? (sumLongDistance / countLong / startPrice) * 100 : 0
avgShortPercent = countShort > 0 ? (sumShortDistance / countShort / startPrice) * 100 : 0

// Affichage dans une box
var table resultsTable = table.new(position.top_right, 3, 3, bgcolor = color.new(color.black, 70))

// Mise à jour de la table
if barstate.islast
    table.cell(resultsTable, 0, 0, "Signal", text_color = color.white)
    table.cell(resultsTable, 1, 0, "Barres", text_color = color.white)
    table.cell(resultsTable, 2, 0, "Distance %", text_color = color.white)
    
    table.cell(resultsTable, 0, 1, "LONG", text_color = color.green)
    table.cell(resultsTable, 1, 1, str.tostring(avgLongBars, "#.##"), text_color = color.green)
    table.cell(resultsTable, 2, 1, str.tostring(avgLongPercent, "#.##") + "%", text_color = color.green)
    
    table.cell(resultsTable, 0, 2, "SHORT", text_color = color.red)
    table.cell(resultsTable, 1, 2, str.tostring(avgShortBars, "#.##"), text_color = color.red)
    table.cell(resultsTable, 2, 2, str.tostring(avgShortPercent, "#.##") + "%", text_color = color.red)

// --- Trade Log Table ---
maxTrades = input.int(defval=10, title="Max trades to display", minval=1, group="Display")
var array<int> tradeTimes = array.new_int()
var array<string> tradeSides = array.new_string()
var array<float> tradePrices = array.new_float()
var table tradeTable = table.new(position.top_left, 4, maxTrades + 1, frame_color=color.gray, frame_width=1, bgcolor=color.new(color.black, 80))

// Record each buy/sell event when it occurs
if validBuyEntry or validSellEntry
    side = validBuyEntry ? "BUY" : "SELL"
    array.unshift(tradeTimes, time)
    array.unshift(tradeSides, side)
    array.unshift(tradePrices, close)
    if array.size(tradeTimes) > maxTrades
        array.pop(tradeTimes)
        array.pop(tradeSides)
        array.pop(tradePrices)

// On final bar, draw the trade log table
if barstate.islast
    // Header row
    table.cell(tradeTable, 0, 0, "Idx",   text_color=color.white, bgcolor=color.blue)
    table.cell(tradeTable, 1, 0, "Time",  text_color=color.white, bgcolor=color.blue)
    table.cell(tradeTable, 2, 0, "Side",  text_color=color.white, bgcolor=color.blue)
    table.cell(tradeTable, 3, 0, "Price", text_color=color.white, bgcolor=color.blue)
    // Populate rows
    for i = 0 to maxTrades - 1
        if i < array.size(tradeTimes)
            tVal = array.get(tradeTimes, i)
            sideVal = array.get(tradeSides, i)
            priceVal = array.get(tradePrices, i)
            timeStr = tostring(tVal, "yyyy-MM-dd HH:mm")
            table.cell(tradeTable, 0, i + 1, str.tostring(i + 1),             text_color=color.green)
            table.cell(tradeTable, 1, i + 1, timeStr,                         text_color=color.white)
            table.cell(tradeTable, 2, i + 1, sideVal,                         text_color= sideVal == "BUY" ? color.green : color.red)
            table.cell(tradeTable, 3, i + 1, str.tostring(priceVal, "#.##"), text_color=color.white)
        else
            table.cell(tradeTable, 0, i + 1, "")
            table.cell(tradeTable, 1, i + 1, "")
            table.cell(tradeTable, 2, i + 1, "")
            table.cell(tradeTable, 3, i + 1, "")