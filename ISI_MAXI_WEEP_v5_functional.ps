//@version=6
strategy('Sweep HTF + Williams Fractal Range & Breakout Strategy', overlay = true, initial_capital = 10000, default_qty_value = 1, default_qty_type = strategy.percent_of_equity, commission_value = 0.01, commission_type = strategy.commission.percent, max_labels_count = 500)

// === 1. INPUTS ===
// -- Sweep & Fractal Inputs --
autoTF = input.timeframe('60', 'HTF Timeframe (Sweep)')
cooldownBars = input.int(10, 'Cooldown Bars (HTF)', minval = 1)
pivotLen = input.int(20, 'Pivot Length (HTF Sweep)', minval = 1)
htfOnly = input.bool(true, 'HTF‑only Breakouts')
showFractal = input.bool(true, 'Show Williams Fractals')
n = input.int(2, 'Fractal Periods (Williams)', minval = 2) // Williams Fractal Period

// -- MTF Trend Filter Inputs --
string grp_mtf = "MTF Trend Filter"
filterLookback = input.int(defval=5, title='Pivot Lookback Period (MTF Filter)', group=grp_mtf, tooltip='Looks for pivot points within this number of bars both left and right for trend filtering.')
filterPivotType = input.string(defval = "High/Low", title = "Pivot Type (MTF Filter)", options = ["High/Low","Close"], group = grp_mtf, tooltip = 'Choose whether the high/low or close is used for pivot points and trend calcuations in the filter.')
filterTF1 = input.timeframe(defval='240', title='Filter Timeframe 1 (e.g., H4)', group=grp_mtf) // Default H4
filterTF2 = input.timeframe(defval='D', title='Filter Timeframe 2 (e.g., D)', group=grp_mtf)   // Default D1
filterTF3 = input.timeframe(defval='W', title='Filter Timeframe 3 (e.g., W)', group=grp_mtf)   // Default W1

// --- Inputs to Enable/Disable each MTF filter ---
filterUseTF1 = input.bool(true, "Use Filter TF1 (H4)?", group=grp_mtf, inline="useTF1")
filterUseTF2 = input.bool(true, "Use Filter TF2 (D1)?", group=grp_mtf, inline="useTF2")
filterUseTF3 = input.bool(false, "Use Filter TF3 (W1)?", group=grp_mtf, inline="useTF3", tooltip="W1 filter is disabled by default.")

// -- Trend Table Display Inputs --
string grp_table = "Trend Display Table"
showTrendTable = input.bool(true, "Show MTF Trend Table?", group=grp_table)
tableLocation = input.string(defval='Top-Right', options=['Top-Right', 'Bottom-Right', 'Top-Left', 'Bottom-Left'], title='Table Location', group=grp_table)

// -- Kill Zone Filter Inputs --
string grp_kz = "Kill Zone Time Filter"
filterByKillZone = input.bool(true, "Filter Trades by Kill Zone Time?", group=grp_kz)
showAsiaKZFilter = input.bool(true, "Asia KZ", group = grp_kz, inline="kz1", tooltip = "Enable filtering for Asia Kill Zone time.")
asiaKZTime = input.session('2300-0355', title="Asia Time", group = grp_kz, inline="kz1")
showLondonKZFilter = input.bool(true, "London KZ", group = grp_kz, inline="kz2", tooltip = "Enable filtering for London Kill Zone time.")
londonKZTime = input.session('0700-0955', title="London Time", group = grp_kz, inline="kz2")
showNyAmKZFilter = input.bool(true, "NY AM KZ", group = grp_kz, inline="kz3", tooltip = "Enable filtering for New York AM Kill Zone time.")
nyAmKZTime = input.session('1430-1655', title="NY AM Time", group = grp_kz, inline="kz3")
showNyPmKZFilter = input.bool(true, "NY PM KZ", group = grp_kz, inline="kz4", tooltip = "Enable filtering for New York PM Kill Zone time.")
nyPmKZTime = input.session('1930-2055', title="NY PM Time", group = grp_kz, inline="kz4")

// === STRATEGY SETTINGS ===
string grp_strategy = "Strategy Settings"
rrRatio = input.float(2.0, "Take Profit R/R Ratio", minval = 0.1, step = 0.1, group = grp_strategy, tooltip="Risk/Reward ratio for Take Profit calculation.")
useStopLoss = input.bool(true, "Use Stop Loss?", group = grp_strategy)
useTakeProfit = input.bool(true, "Use Take Profit?", group = grp_strategy)

// === 2. HTF PIVOTS ===
// Removed unused htfPLow/htfPHigh requests
// htfPLow = request.security(syminfo.tickerid, autoTF, ta.pivotlow(low, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)
// htfPHigh = request.security(syminfo.tickerid, autoTF, ta.pivothigh(high, pivotLen, pivotLen), lookahead=barmerge.lookahead_off)

// Store the actual values of pivots when they occur
htfVLow = request.security(syminfo.tickerid, autoTF, ta.valuewhen(not na(ta.pivotlow(low, pivotLen, pivotLen)), low[pivotLen], 0), lookahead = barmerge.lookahead_off)
htfVHigh = request.security(syminfo.tickerid, autoTF, ta.valuewhen(not na(ta.pivothigh(high, pivotLen, pivotLen)), high[pivotLen], 0), lookahead = barmerge.lookahead_off)

// Track previous pivot values to detect changes
var float prevVLow = na
var float prevVHigh = na
bool lowPivotChanged = htfVLow != prevVLow and not na(htfVLow)
bool highPivotChanged = htfVHigh != prevVHigh and not na(htfVHigh)

// Store the levels to be displayed, updated only on change
var float displayVLow = na
var float displayVHigh = na

if lowPivotChanged
    displayVLow := htfVLow // Update display level only when pivot changes
    displayVLow

if highPivotChanged
    displayVHigh := htfVHigh // Update display level only when pivot changes
    displayVHigh

// Store current pivot values for next bar comparison 
if not na(htfVLow)
    prevVLow := htfVLow
    prevVLow
if not na(htfVHigh)
    prevVHigh := htfVHigh
    prevVHigh

// Plot the persistent display levels using stepline for distinct horizontal lines
plot(displayVLow, 'HTF Low Pivot', color = color.lime, style = plot.style_stepline, linewidth = 1)
plot(displayVHigh, 'HTF High Pivot', color = color.red, style = plot.style_stepline, linewidth = 1)

// Get current HTF time only if needed for breakout detection
// htfTime = request.security(syminfo.tickerid, autoTF, time, lookahead = barmerge.lookahead_off) // Potentially remove if not used elsewhere
// bool isNewHTFBar = ta.change(htfTime) != 0

// === MTF TREND FILTER LOGIC ===
// Define functions for use in multiple timeframes (using a tuple to avoid so many security calls)
f_getHTFFilter(_lookback, _pivotType) =>
    var float ph = na, float pl = na, float highLevel = na, float lowLevel = na
    if _pivotType == "Close"
        ph := ta.pivothigh(close, _lookback, _lookback)
        pl := ta.pivotlow(close, _lookback, _lookback)
        highLevel := ta.valuewhen(not na(ph), close[_lookback], 0)
        lowLevel := ta.valuewhen(not na(pl), close[_lookback], 0)
    else
        ph := ta.pivothigh(high, _lookback, _lookback)
        pl := ta.pivotlow(low, _lookback, _lookback)
        highLevel := ta.valuewhen(not na(ph), high[_lookback], 0)
        lowLevel := ta.valuewhen(not na(pl), low[_lookback], 0)
    [highLevel, lowLevel] // Only return the levels needed for trend calc

f_signalFilter(highLevel, lowLevel) =>
    uptrendSignal = high > highLevel
    downtrendSignal = low < lowLevel
    var bool inUptrend = false // Default to false (not in uptrend)
    
    if uptrendSignal[1] 
        inUptrend := true
    else if downtrendSignal[1]
        inUptrend := false

    inDowntrend = not inUptrend 
    [inUptrend, inDowntrend]

// Function to fill trend table cell (moved to global scope)
f_fillCell(_table, _column, _text, _isFilterActive, _isUp, _isDown, _tfString, upColor, downColor, bgColor) =>
    // Determine color and prefix based on filter active status and trend
    color cellColor = na
    string cellPrefix = ""
    
    if not _isFilterActive
        cellColor := color.new(color.gray, 60) // Gray out if filter is off
        cellPrefix := "~ " // Neutral prefix, or could be empty
    else if _isUp
        cellColor := upColor
        cellPrefix := "▲ "
    else if _isDown
        cellColor := downColor
        cellPrefix := "▼ "
    else
        cellColor := bgColor // Filter is active, but trend is neutral/undetermined
        cellPrefix := "~ "
        
    cellText = _isFilterActive ? cellPrefix + _tfString : _tfString + " Off" // Add " Off" if filter inactive
    
    table.cell(_table, _column, 0, cellText, bgcolor=cellColor, text_color=color.white, width = 6)

// Function to get active filters string (Moved here, before usage)
getActiveFiltersString(tf1, use1, up1, down1, tf2, use2, up2, down2, tf3, use3, up3, down3) =>
    var string parts = ""
    parts := ""
    
    if use1
        parts += str.tostring(tf1) + (up1 ? "+" : down1 ? "-" : "~") + " "
    if use2
        parts += str.tostring(tf2) + (up2 ? "+" : down2 ? "-" : "~") + " "
    if use3
        parts += str.tostring(tf3) + (up3 ? "+" : down3 ? "-" : "~") + " "
    
    result = parts == "" ? "None Active" : str.trim(parts)
    result

// Get MTF Filter Data using the functions
[hL_F1, lL_F1] = request.security(syminfo.tickerid, filterTF1, f_getHTFFilter(filterLookback, filterPivotType))
[hL_F2, lL_F2] = request.security(syminfo.tickerid, filterTF2, f_getHTFFilter(filterLookback, filterPivotType))
[hL_F3, lL_F3] = request.security(syminfo.tickerid, filterTF3, f_getHTFFilter(filterLookback, filterPivotType))

// Calculate MTF Filter Trends
[inUptrendF1, inDowntrendF1] = f_signalFilter(hL_F1, lL_F1)  // Filter Timeframe 1 (H4)
[inUptrendF2, inDowntrendF2] = f_signalFilter(hL_F2, lL_F2)  // Filter Timeframe 2 (D1)
[inUptrendF3, inDowntrendF3] = f_signalFilter(hL_F3, lL_F3)  // Filter Timeframe 3 (W1)

// --- Boolean flags for convenience ---
bool isTrendUpH4 = inUptrendF1
bool isTrendDownH4 = inDowntrendF1
bool isTrendUpD1 = inUptrendF2
bool isTrendDownD1 = inDowntrendF2
bool isTrendUpW1 = inUptrendF3
bool isTrendDownW1 = inDowntrendF3

// Calculate active filters string (now function is defined above)
string activeFiltersStr = getActiveFiltersString(filterTF1, filterUseTF1, isTrendUpH4, isTrendDownH4, filterTF2, filterUseTF2, isTrendUpD1, isTrendDownD1, filterTF3, filterUseTF3, isTrendUpW1, isTrendDownW1)

// Filter Conditions - Check alignment ONLY for ENABLED filters
// If filterUseTFx is false, the condition (not filterUseTFx or isTrend...) becomes true, effectively ignoring that TF.
bool bullFilterCondition = 
  (not filterUseTF1 or isTrendUpH4) and 
  (not filterUseTF2 or isTrendUpD1) and 
  (not filterUseTF3 or isTrendUpW1)

bool bearFilterCondition = 
  (not filterUseTF1 or isTrendDownH4) and 
  (not filterUseTF2 or isTrendDownD1) and 
  (not filterUseTF3 or isTrendDownW1)

// === KILL ZONE TIME CHECK ===
// Function to check if current bar is in a specific session time
// Note: time() checks against the *chart's* timeframe. 
is_in_session(sess) => na(time(timeframe.period, sess)) ? false : true // time() returns na if not in session

// Check individual Kill Zones if enabled
bool inAsiaKZ = showAsiaKZFilter and is_in_session(asiaKZTime)
bool inLondonKZ = showLondonKZFilter and is_in_session(londonKZTime)
bool inNyAmKZ = showNyAmKZFilter and is_in_session(nyAmKZTime)
bool inNyPmKZ = showNyPmKZFilter and is_in_session(nyPmKZTime)

// Combine into one flag: are we in *any* active Kill Zone?
bool isInActiveKillZone = filterByKillZone and (inAsiaKZ or inLondonKZ or inNyAmKZ or inNyPmKZ)

// Determine which KZ is active for logging/alerts
string currentActiveKZ = if not filterByKillZone
    "Disabled"
else if inAsiaKZ
    "Asia"
else if inLondonKZ
    "London"
else if inNyAmKZ
    "NY AM"
else if inNyPmKZ
    "NY PM"
else
    "None"

// Final filter condition including Kill Zone check (if enabled)
bool killZoneFilterActive = not filterByKillZone or isInActiveKillZone

// === 5. FRACTAL RANGE & BREAKOUT === (Variables)
// Bullish state - after touching HTF low
var bool bullActive = false
var int bullSweepBar = na
var box bullBox = na
var bool bullDone = false
var bool bullBreakoutDetected = false
var bool bullBoxCreated = false
var bool foundBullHighFractal = false
var int bullHighFractalIndex = na
var float bullHighFractalLevel = na
var bool foundBullLowFractal = false
var int bullLowFractalIndex = na
var float bullLowFractalLevel = na
var line breakoutLine = na // Line to mark the breakout level
var line slLine = na // Line for Stop Loss
var float slLevel = na // SL Level value

// Bearish state - after touching HTF high
var bool bearActive = false
var int bearSweepBar = na
var box bearBox = na
var bool bearDone = false
var bool bearBreakoutDetected = false
var bool bearBoxCreated = false
var bool foundBearHighFractal = false
var int bearHighFractalIndex = na
var float bearHighFractalLevel = na
var bool foundBearLowFractal = false
var int bearLowFractalIndex = na
var float bearLowFractalLevel = na

// Active Trade SL/TP levels
var float activeLongSL = na
var float activeLongTP = na
var float activeShortSL = na
var float activeShortTP = na

// === 3. SWEEP/INDUCEMENT DETECTION (Formerly TOUCH DETECTION) ===
var int lastLowSweepBar = na
var int lastHighSweepBar = na
var bool sweptLow = false
var bool sweptHigh = false

// Reset sweep state when new pivots are detected
if lowPivotChanged
    sweptLow := false
    lastLowSweepBar := na
    lastLowSweepBar
if highPivotChanged
    sweptHigh := false
    lastHighSweepBar := na
    lastHighSweepBar

// Check for new sweeps with proper cooldown - Trigger on CLOSE crossing the level
if not sweptLow and (na(lastLowSweepBar) or bar_index >= lastLowSweepBar + cooldownBars) and close < htfVLow and not na(htfVLow)
    sweptLow := true
    lastLowSweepBar := bar_index
    lastLowSweepBar

if not sweptHigh and (na(lastHighSweepBar) or bar_index >= lastHighSweepBar + cooldownBars) and close > htfVHigh and not na(htfVHigh)
    sweptHigh := true
    lastHighSweepBar := bar_index
    lastHighSweepBar

// Highlight sweep bars only if we haven't had a breakout detection for that sweep
bool bullBreakoutHappened = bullBreakoutDetected and bar_index > lastLowSweepBar
bool bearBreakoutHappened = bearBreakoutDetected and bar_index > lastHighSweepBar

barcolor(bar_index == lastLowSweepBar and not bullBreakoutHappened ? color.green : bar_index == lastHighSweepBar and not bearBreakoutHappened ? color.red : na)

// === 4. WILLIAMS FRACTALS LOGIC ===
// UpFractal (High Fractal)
bool upflagDownFrontier = true
bool upflagUpFrontier0 = true
bool upflagUpFrontier1 = true
bool upflagUpFrontier2 = true
bool upflagUpFrontier3 = true
bool upflagUpFrontier4 = true

for i = 1 to n by 1
    upflagDownFrontier := upflagDownFrontier and high[n - i] < high[n]
    upflagUpFrontier0 := upflagUpFrontier0 and high[n + i] < high[n]
    upflagUpFrontier1 := upflagUpFrontier1 and high[n + 1] <= high[n] and high[n + i + 1] < high[n]
    upflagUpFrontier2 := upflagUpFrontier2 and high[n + 1] <= high[n] and high[n + 2] <= high[n] and high[n + i + 2] < high[n]
    upflagUpFrontier3 := upflagUpFrontier3 and high[n + 1] <= high[n] and high[n + 2] <= high[n] and high[n + 3] <= high[n] and high[n + i + 3] < high[n]
    upflagUpFrontier4 := upflagUpFrontier4 and high[n + 1] <= high[n] and high[n + 2] <= high[n] and high[n + 3] <= high[n] and high[n + 4] <= high[n] and high[n + i + 4] < high[n]
    upflagUpFrontier4
flagUpFrontier = upflagUpFrontier0 or upflagUpFrontier1 or upflagUpFrontier2 or upflagUpFrontier3 or upflagUpFrontier4

upFractal = upflagDownFrontier and flagUpFrontier

// downFractal (Low Fractal)
bool downflagDownFrontier = true
bool downflagUpFrontier0 = true
bool downflagUpFrontier1 = true
bool downflagUpFrontier2 = true
bool downflagUpFrontier3 = true
bool downflagUpFrontier4 = true

for i = 1 to n by 1
    downflagDownFrontier := downflagDownFrontier and low[n - i] > low[n]
    downflagUpFrontier0 := downflagUpFrontier0 and low[n + i] > low[n]
    downflagUpFrontier1 := downflagUpFrontier1 and low[n + 1] >= low[n] and low[n + i + 1] > low[n]
    downflagUpFrontier2 := downflagUpFrontier2 and low[n + 1] >= low[n] and low[n + 2] >= low[n] and low[n + i + 2] > low[n]
    downflagUpFrontier3 := downflagUpFrontier3 and low[n + 1] >= low[n] and low[n + 2] >= low[n] and low[n + 3] >= low[n] and low[n + i + 3] > low[n]
    downflagUpFrontier4 := downflagUpFrontier4 and low[n + 1] >= low[n] and low[n + 2] >= low[n] and low[n + 3] >= low[n] and low[n + 4] >= low[n] and low[n + i + 4] > low[n]
    downflagUpFrontier4
flagDownFrontier = downflagUpFrontier0 or downflagUpFrontier1 or downflagUpFrontier2 or downflagUpFrontier3 or downflagUpFrontier4

downFractal = downflagDownFrontier and flagDownFrontier

// Use Williams fractal logic for isHighFractal and isLowFractal
bool isHighFractal = upFractal
bool isLowFractal = downFractal

// Plot Williams Fractals based on the logic
plotshape(showFractal and isHighFractal, title = 'H Fractal', style = shape.triangledown, location = location.abovebar, offset = -n, color = color.new(color.red, 0))
plotshape(showFractal and isLowFractal, title = 'L Fractal', style = shape.triangleup, location = location.belowbar, offset = -n, color = color.new(color.lime, 0))

// === 5. FRACTAL RANGE & BREAKOUT === (Logic)
// Reset state on new HTF level
if lowPivotChanged
    bullActive := false
    bullDone := false
    bullBreakoutDetected := false
    bullBoxCreated := false
    foundBullHighFractal := false
    foundBullLowFractal := false
    if not na(breakoutLine)
        line.delete(breakoutLine) // Delete old breakout line
        breakoutLine := na
    if not na(bullBox)
        box.delete(bullBox)
        bullBox := na
    if not na(slLine)
        line.delete(slLine) // Delete old SL line
        slLine := na

if highPivotChanged
    bearActive := false
    bearDone := false
    bearBreakoutDetected := false
    bearBoxCreated := false
    foundBearHighFractal := false
    foundBearLowFractal := false
    if not na(breakoutLine)
        line.delete(breakoutLine) // Delete old breakout line
        breakoutLine := na
    if not na(bearBox)
        box.delete(bearBox)
        bearBox := na
    if not na(slLine)
        line.delete(slLine) // Delete old SL line
        slLine := na

// Start tracking after SWEEP (not touch)
if sweptLow and not bullActive and not bullBreakoutDetected
    bullActive := true
    bullSweepBar := bar_index
    // Reset fractal search state for bull
    foundBullHighFractal := false
    bullHighFractalIndex := na
    bullHighFractalLevel := na
    foundBullLowFractal := false
    bullLowFractalIndex := na
    bullLowFractalLevel := na
    bullDone := false
    bullBoxCreated := false
    if not na(breakoutLine)
        line.delete(breakoutLine) // Delete old breakout line on new sweep
        breakoutLine := na
    if not na(bullBox)
        box.delete(bullBox)
        bullBox := na
    if not na(slLine)
        line.delete(slLine) // Delete old SL line on new sweep
        slLine := na

if sweptHigh and not bearActive and not bearBreakoutDetected
    bearActive := true
    bearSweepBar := bar_index
    // Reset fractal search state for bear
    foundBearHighFractal := false
    bearHighFractalIndex := na
    bearHighFractalLevel := na
    foundBearLowFractal := false
    bearLowFractalIndex := na
    bearLowFractalLevel := na
    bearDone := false
    bearBoxCreated := false
    if not na(breakoutLine)
        line.delete(breakoutLine) // Delete old breakout line on new sweep
        breakoutLine := na
    if not na(bearBox)
        box.delete(bearBox)
        bearBox := na
    if not na(slLine)
        line.delete(slLine) // Delete old SL line on new sweep
        slLine := na

// --- Find First High and Low Fractals after Sweep ---

// Bull: Search for first High Fractal
if bullActive and not bullBoxCreated and not foundBullHighFractal
    fractalActualBarIndex = bar_index - n
    if isHighFractal and fractalActualBarIndex >= bullSweepBar
        foundBullHighFractal := true
        bullHighFractalIndex := fractalActualBarIndex
        bullHighFractalLevel := high[n]
        // Debug
        label.new(bullHighFractalIndex, bullHighFractalLevel, 'H1', style = label.style_none, color = color.yellow, textcolor = color.yellow, size = size.tiny)

// Bull: Search for first Low Fractal
if bullActive and not bullBoxCreated and not foundBullLowFractal
    fractalActualBarIndex = bar_index - n
    if isLowFractal and fractalActualBarIndex >= bullSweepBar
        foundBullLowFractal := true
        bullLowFractalIndex := fractalActualBarIndex
        bullLowFractalLevel := low[n]
        // Debug
        label.new(bullLowFractalIndex, bullLowFractalLevel, 'L1', style = label.style_none, color = color.yellow, textcolor = color.yellow, size = size.tiny)

// Bear: Search for first High Fractal
if bearActive and not bearBoxCreated and not foundBearHighFractal
    fractalActualBarIndex = bar_index - n
    if isHighFractal and fractalActualBarIndex >= bearSweepBar
        foundBearHighFractal := true
        bearHighFractalIndex := fractalActualBarIndex
        bearHighFractalLevel := high[n]
        // Debug
        label.new(bearHighFractalIndex, bearHighFractalLevel, 'H1', style = label.style_none, color = color.blue, textcolor = color.blue, size = size.tiny)

// Bear: Search for first Low Fractal
if bearActive and not bearBoxCreated and not foundBearLowFractal
    fractalActualBarIndex = bar_index - n
    if isLowFractal and fractalActualBarIndex >= bearSweepBar
        foundBearLowFractal := true
        bearLowFractalIndex := fractalActualBarIndex
        bearLowFractalLevel := low[n]
        // Debug
        label.new(bearLowFractalIndex, bearLowFractalLevel, 'L1', style = label.style_none, color = color.blue, textcolor = color.blue, size = size.tiny)

// --- Create Box once both Fractals are found ---

// Bull Box Creation
if bullActive and foundBullHighFractal and foundBullLowFractal and not bullBoxCreated
    boxTop = bullHighFractalLevel
    boxBottom = bullLowFractalLevel
    boxLeft = math.min(bullHighFractalIndex, bullLowFractalIndex)
    boxRight = math.max(bullHighFractalIndex, bullLowFractalIndex)
    // Create the box
    bullBox := box.new(left = boxLeft, right = boxRight, top = boxTop, bottom = boxBottom, xloc = xloc.bar_index, border_color = color.green, bgcolor = color.new(color.green, 90), extend = extend.right)
    bullBoxCreated := true // Mark box as created

// Bear Box Creation
if bearActive and foundBearHighFractal and foundBearLowFractal and not bearBoxCreated
    boxTop = bearHighFractalLevel
    boxBottom = bearLowFractalLevel
    boxLeft = math.min(bearHighFractalIndex, bearLowFractalIndex)
    boxRight = math.max(bearHighFractalIndex, bearLowFractalIndex)
    // Create the box
    bearBox := box.new(left = boxLeft, right = boxRight, top = boxTop, bottom = boxBottom, xloc = xloc.bar_index, border_color = color.red, bgcolor = color.new(color.red, 90), extend = extend.right)
    bearBoxCreated := true // Mark box as created

// Breakout detection
float breakoutLevel = na
color breakColor = na
bool isBreakout = false
bool bullAlertTrigger = false // Alert trigger for bull confirmation
bool bearAlertTrigger = false // Alert trigger for bear confirmation

// Bull breakout (après touche Vert Bas)
if bullActive and bullBoxCreated and not bullDone and not bullBreakoutDetected and not na(bullBox)
    // Reset breakout info for this bar check
    breakoutLevel := na
    breakColor := na
    isBreakout := false
    slLevel := na // Reset SL level each bar check within active phase

    if close > bullHighFractalLevel // Break HAUT -> Confirmation
        label.new(bar_index, bullHighFractalLevel, '▲', style = label.style_label_up, color = color.new(color.green, 80), textcolor = color.green, size = size.normal)
        breakoutLevel := bullHighFractalLevel
        breakColor := color.green
        isBreakout := true
        bullAlertTrigger := true // Trigger alert

        // Calculate SL for confirming bullish breakout
        slLevel := bullLowFractalLevel // SL below the range low
        // Trigger entry if filters pass and no position is open
        if bullFilterCondition and killZoneFilterActive and strategy.position_size == 0
            activeLongSL := slLevel
            activeLongTP := bullHighFractalLevel + (bullHighFractalLevel - slLevel) * rrRatio // TP from breakout level
            strategy.entry("Long", strategy.long, comment="L Entry", alert_message = "BUY " + syminfo.ticker + " SL: " + str.tostring(activeLongSL, format.mintick))
            // alert("BUY " + syminfo.ticker + " SL: " + str.tostring(slLevel, format.mintick), alert.freq_once_per_bar) // Replaced by strategy.entry

        // Debug: Show SL for confirming breakout
        label.new(bar_index, slLevel, 'Debug SL: ' + str.tostring(slLevel, format.mintick), style = label.style_label_left, color = color.new(color.gray, 50), textcolor = color.gray, size = size.tiny)

    else if close < bullLowFractalLevel // Break BAS -> Contre
        label.new(bar_index, bullLowFractalLevel, '✗', style = label.style_label_down, color = color.new(color.red, 80), textcolor = color.red, size = size.normal)
        breakoutLevel := bullLowFractalLevel
        breakColor := color.red
        isBreakout := true
        // Ensure SL line from previous (now invalid) state is removed
        if not na(slLine)
            line.delete(slLine)
            slLine := na

    // If a breakout happened, update/create the breakout line and finalize state
    if isBreakout
        // Update or Create Breakout Line
        if na(breakoutLine)
            breakoutLine := line.new(bar_index, breakoutLevel, bar_index + 10, breakoutLevel, color = breakColor, style = line.style_solid, width = 1)
        else
            line.set_xy1(breakoutLine, bar_index, breakoutLevel)
            line.set_xy2(breakoutLine, bar_index + 10, breakoutLevel)
            line.set_color(breakoutLine, breakColor)
            line.set_style(breakoutLine, line.style_solid)

        // Draw SL line ONLY for confirming breakouts
        if bullAlertTrigger and not na(slLevel)
            // Update or Create SL Line
            if na(slLine)
                slLine := line.new(bar_index, slLevel, bar_index + 10, slLevel, color = color.orange, style = line.style_dashed, width = 1)
            else
                line.set_xy1(slLine, bar_index, slLevel)
                line.set_xy2(slLine, bar_index + 10, slLevel)
                line.set_color(slLine, color.orange)
                line.set_style(slLine, line.style_dashed)

        box.set_extend(bullBox, extend.none) // Stop box extension
        bullDone := true
        bullBreakoutDetected := true
        bullActive := false

// Bear breakout (après touche Rouge Haut)
if bearActive and bearBoxCreated and not bearDone and not bearBreakoutDetected and not na(bearBox)
    // Reset breakout info for this bar check
    breakoutLevel := na
    breakColor := na
    isBreakout := false
    slLevel := na // Reset SL level each bar check within active phase

    if close < bearLowFractalLevel // Break BAS -> Confirmation
        label.new(bar_index, bearLowFractalLevel, '▼', style = label.style_label_down, color = color.new(color.red, 80), textcolor = color.red, size = size.normal)
        breakoutLevel := bearLowFractalLevel
        breakColor := color.red
        isBreakout := true
        bearAlertTrigger := true // Trigger alert

        // Calculate SL for confirming bearish breakout
        slLevel := bearHighFractalLevel // SL above the range high
        // Trigger entry if filters pass and no position is open
        if bearFilterCondition and killZoneFilterActive and strategy.position_size == 0
            activeShortSL := slLevel
            activeShortTP := bearLowFractalLevel - (slLevel - bearLowFractalLevel) * rrRatio // TP from breakout level
            strategy.entry("Short", strategy.short, comment="S Entry", alert_message = "SELL " + syminfo.ticker + " SL: " + str.tostring(activeShortSL, format.mintick))
            // alert("SELL " + syminfo.ticker + " SL: " + str.tostring(slLevel, format.mintick), alert.freq_once_per_bar) // Replaced by strategy.entry

        // Debug: Show SL for confirming breakout
        label.new(bar_index, slLevel, 'Debug SL: ' + str.tostring(slLevel, format.mintick), style = label.style_label_left, color = color.new(color.gray, 50), textcolor = color.gray, size = size.tiny)

    else if close > bearHighFractalLevel // Break HAUT -> Contre
        label.new(bar_index, bearHighFractalLevel, '✗', style = label.style_label_up, color = color.new(color.green, 80), textcolor = color.green, size = size.normal)
        breakoutLevel := bearHighFractalLevel
        breakColor := color.green
        isBreakout := true
        // Ensure SL line from previous (now invalid) state is removed
        if not na(slLine)
            line.delete(slLine)
            slLine := na

    // If a breakout happened, update/create the breakout line and finalize state
    if isBreakout
        // Update or Create Breakout Line
        if na(breakoutLine)
            breakoutLine := line.new(bar_index, breakoutLevel, bar_index + 10, breakoutLevel, color = breakColor, style = line.style_solid, width = 1)
        else
            line.set_xy1(breakoutLine, bar_index, breakoutLevel)
            line.set_xy2(breakoutLine, bar_index + 10, breakoutLevel)
            line.set_color(breakoutLine, breakColor)
            line.set_style(breakoutLine, line.style_solid)

        // Draw SL line ONLY for confirming breakouts
        if bearAlertTrigger and not na(slLevel)
            // Update or Create SL Line
            if na(slLine)
                slLine := line.new(bar_index, slLevel, bar_index + 10, slLevel, color = color.orange, style = line.style_dashed, width = 1)
            else
                line.set_xy1(slLine, bar_index, slLevel)
                line.set_xy2(slLine, bar_index + 10, slLevel)
                line.set_color(slLine, color.orange)
                line.set_style(slLine, line.style_dashed)

        box.set_extend(bearBox, extend.none) // Stop box extension
        bearDone := true
        bearBreakoutDetected := true
        bearActive := false

// === STRATEGY EXIT LOGIC ===
if strategy.position_size > 0 // If long position is open
    if useStopLoss and useTakeProfit and not na(activeLongSL) and not na(activeLongTP)
        strategy.exit("L Exit", "Long", stop=activeLongSL, limit=activeLongTP)
    else if useStopLoss and not na(activeLongSL)
        strategy.exit("L SL", "Long", stop=activeLongSL)
    else if useTakeProfit and not na(activeLongTP)
        strategy.exit("L TP", "Long", limit=activeLongTP)

if strategy.position_size < 0 // If short position is open
    if useStopLoss and useTakeProfit and not na(activeShortSL) and not na(activeShortTP)
        strategy.exit("S Exit", "Short", stop=activeShortSL, limit=activeShortTP)
    else if useStopLoss and not na(activeShortSL)
        strategy.exit("S SL", "Short", stop=activeShortSL)
    else if useTakeProfit and not na(activeShortTP)
        strategy.exit("S TP", "Short", limit=activeShortTP)

// === MTF TREND DISPLAY TABLE ===
var table trendTable = na
tablePos = switch tableLocation
    'Top-Right' => position.top_right
    'Bottom-Right' => position.bottom_right
    'Top-Left' => position.top_left
    'Bottom-Left' => position.bottom_left
    => position.top_right // Default

if showTrendTable and barstate.islast
    if na(trendTable) // Create table only once
        trendTable := table.new(tablePos, 3, 1, border_width=1)
    else
        // Clear previous content if reusing table (safer)
        table.clear(trendTable, 0, 0, 2, 0)

    // Colors (defined locally within the if block)
    upColorTable = color.new(color.green, 20)
    downColorTable = color.new(color.red, 20)
    bgColorTable = color.new(color.gray, 80)

    // Function to fill cell (simplified)
    // Moved definition to global scope

    // Fill the table cells (passing filter active status and colors as arguments)
    f_fillCell(trendTable, 0, filterTF1, filterUseTF1, isTrendUpH4, isTrendDownH4, str.tostring(filterTF1), upColorTable, downColorTable, bgColorTable)
    f_fillCell(trendTable, 1, filterTF2, filterUseTF2, isTrendUpD1, isTrendDownD1, str.tostring(filterTF2), upColorTable, downColorTable, bgColorTable)
    f_fillCell(trendTable, 2, filterTF3, filterUseTF3, isTrendUpW1, isTrendDownW1, str.tostring(filterTF3), upColorTable, downColorTable, bgColorTable)

else if not na(trendTable) and barstate.islast // Hide table if showTrendTable is false
    table.delete(trendTable)
    trendTable := na // Reset variable

// Pre-calculate log strings for trends based on filter status (to avoid complex ternaries in log.info)
string logTrendH4 = filterUseTF1 ? (isTrendUpH4 ? "Up" : isTrendDownH4 ? "Down" : "N/A") : "Off"
string logTrendD1 = filterUseTF2 ? (isTrendUpD1 ? "Up" : isTrendDownD1 ? "Down" : "N/A") : "Off"
string logTrendW1 = filterUseTF3 ? (isTrendUpW1 ? "Up" : isTrendDownW1 ? "Down" : "N/A") : "Off"

log.info("--- End Bar {0} --- Trend H4: {1}, D1: {2}, W1: {3} --- Kill Zone: {4} | Active Filters: {5} ---", 
  bar_index, 
  logTrendH4, // Use pre-calculated string
  logTrendD1, // Use pre-calculated string
  logTrendW1, // Use pre-calculated string
  currentActiveKZ, 
  activeFiltersStr) // Log end of bar execution and filter status
